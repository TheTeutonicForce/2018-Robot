// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Robot.h"// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
std::shared_ptr<Driving> Robot::driving;
std::shared_ptr<Climbing> Robot::climbing;
std::shared_ptr<Arm> Robot::arm;
std::shared_ptr<Accel> Robot::accel;
std::shared_ptr<CameraSub> Robot::camerasub;
std::unique_ptr<OI> Robot::oi;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION

void Robot::RobotInit() {
	RobotMap::init();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    driving.reset(new Driving());
    climbing.reset(new Climbing());
    arm.reset(new Arm());
    accel.reset(new Accel());
    camerasub.reset(new CameraSub());
    m_autocommand = 0;
    m_positionchooser = 0;
    m_done = false;

    gameData = "";

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	// This MUST be here. If the OI creates Commands (which it very likely
	// will), constructing it during the construction of CommandBase (from
	// which commands extend), subsystems are not guaranteed to be
	// yet. Thus, their requires() statements may grab null pointers. Bad
	// news. Don't move it.
	oi.reset(new OI());
	cam0=frc::CameraServer::GetInstance()->StartAutomaticCapture();
	cam0.SetResolution(320,240);
	cam1=frc::CameraServer::GetInstance()->StartAutomaticCapture();
	cam1.SetResolution(320,240);
	cs::CvSink cvSink=frc::CameraServer::GetInstance()->GetVideo();
	cs::CvSource outputStreamStd = frc::CameraServer::GetInstance()->PutVideo("BobVideo",640,480);
	cv::Mat source;
	cv::Mat output;
	frc::SmartDashboard::PutNumber("Destination : ",m_autocommand);
	frc::SmartDashboard::PutNumber("Starting Location : ", m_positionchooser);
	// Add commands to Autonomous Sendable Chooser
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS


}

/**
 * This function is called when the disabled button is hit.
 * You can use it to reset subsystems before shutting down.
 */
void Robot::DisabledInit(){

}

void Robot::DisabledPeriodic() {
	frc::Scheduler::GetInstance()->Run();
}

void Robot::AutonomousInit() {
	gameData = "";
	gameData = frc::DriverStation::GetInstance().GetGameSpecificMessage();
	frc::SmartDashboard::PutString("Gamedata: ",gameData);
/*
	if(gameData[0] == 'L')
	{
		frc::SmartDashboard::PutString("CloseSwitch", "Lift");
	}
	else{
		frc::SmartDashboard::PutString("CloseSwitch", "Right");
	}
	if(gameData[1] == 'L')
	{
		frc::SmartDashboard::PutString("Scale", "Left");
	}
	else{
		frc::SmartDashboard::PutString("Scale", "Right");
	}

	if(gameData[2] == 'L')
	{
		frc::SmartDashboard::PutString("FarSwitch", "Left");
	}
	else{
		frc::SmartDashboard::PutString("FarSwitch", "Right");
	}
*/


	m_autocommand = frc::SmartDashboard::GetNumber("Destination : ",m_autocommand);
	frc::SmartDashboard::PutNumber("Auto Feedback",m_autocommand);

	m_positionchooser = frc::SmartDashboard::GetNumber("Starting Location : ", m_positionchooser);
	frc::SmartDashboard::PutNumber("Position Confirmation", m_positionchooser);


//1 = right
//2 = center
//3 = left


if(m_positionchooser ==1)
{

	switch(m_autocommand){

	case 1: //closeSwitch
		if(gameData[0] == 'L')
		{
			selected.reset(new AM_R_CloseSwitch_Left());
		}
		else{
			selected.reset(new AM_R_CloseSwitch_Right());
		}
			break;
	case 2:
			selected.reset(new AM_R_CrossTheLine());
			break;
	case 3:
			selected.reset(new AM_R_ExchangeCube());
			break;
	case 4: //FarSwitch
		if(gameData[2] == 'L'){
			selected.reset(new AM_R_FarSwitch_Left());
		}
		else{
			selected.reset(new AM_R_FarSwitch_Right());
		}
			break;
	case 5://Scale
		if(gameData[1] == 'L'){
			selected.reset(new AM_R_Scale_Left());
		}
		else{
			selected.reset(new AM_R_Scale_Right());
		}
			break;

	default:
		std::printf ("Invalid Autonomouse Selection!");
				selected.reset(new DoNothing());
				break;
	}
}


else if(m_positionchooser ==2)
{

	switch(m_autocommand){

	case 1: //closeSwitch
		if(gameData[0] == 'L')
		{
			selected.reset(new AM_C_CloseSwitch_Left());
		}
		else{
			selected.reset(new AM_C_CloseSwitch_Right());
		}
			break;
	case 2:
			selected.reset(new AM_C_CrossTheLine());
			break;
	case 3:
			selected.reset(new AM_C_ExchangeCube());
			break;
	case 4: //FarSwitch
		if(gameData[2] == 'L'){
			selected.reset(new AM_C_FarSwitch_Left());
		}
		else{
			selected.reset(new AM_C_FarSwitch_Right());
		}
			break;
	case 5://Scale
		if(gameData[1] == 'L'){
			selected.reset(new AM_C_Scale_Left());
		}
		else{
			selected.reset(new AM_C_Scale_Right());
		}
			break;

	default:
		std::printf ("Invalid Autonomouse Selection!");
				selected.reset(new DoNothing());
				break;
	}
}

else if(m_positionchooser ==3)
{

	switch(m_autocommand){

	case 1: //closeSwitch
		if(gameData[0] == 'L')
		{
			selected.reset(new AM_L_CloseSwitch_Left());
		}
		else{
			selected.reset(new AM_L_CloseSwitch_Right());
		}
			break;
	case 2:
			selected.reset(new AM_L_CrossTheLine());
			break;
	case 3:
			selected.reset(new AM_L_ExchangeCube());
			break;
	case 4: //FarSwitch
		if(gameData[2] == 'L'){
			selected.reset(new AM_L_FarSwitch_Left());
		}
		else{
			selected.reset(new AM_L_FarSwitch_Right());
		}
			break;
	case 5://Scale
		if(gameData[1] == 'L'){
			selected.reset(new AM_L_Scale_Left());
		}
		else{
			selected.reset(new AM_L_Scale_Right());
		}
			break;

	default:
		std::printf ("Invalid Autonomouse Selection!");
				selected.reset(new DoNothing());
				break;
	}
}
else selected.reset(new DoNothing());


}

void Robot::AutonomousPeriodic() {
	frc::Scheduler::GetInstance()->Run();
	if (!m_done) {   //autonomous command must run only once!
		selected->Start();
		m_done = true; // run once and that's it
	}
}

void Robot::TeleopInit() {
	// This makes sure that the autonomous stops running when
	// teleop starts running. If you want the autonomous to
	// continue until interrupted by another command, remove
	// these lines or comment it out.
	if (autonomousCommand != nullptr)
		autonomousCommand->Cancel();
	if (selected != nullptr)
		selected->Cancel();
	chassis.reset(new Chassis());
	armcommand.reset(new ArmCommand());

}

void Robot::TeleopPeriodic() {
	frc::Scheduler::GetInstance()->Run();
	chassis->Start();
	armcommand->Start();
}

START_ROBOT_CLASS(Robot);

